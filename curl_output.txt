Starting backend tests...
--- /generate-quiz tests ---
Testing Beginner Quiz...
URL: http://localhost:8000/generate-quiz
Payload: {"topic": "Python lists", "question_number": 2, "level": "beginner"}
Status Code: 200
Response Body:
{"questions":[{"question_number_text":"Q1.","question":"What is the correct way to access the third element in a Python list named 'my_list'?","code":"","options":{"A":"my_list(3)","B":"my_list[2]","C":"my_list[3]","D":"my_list.get(3)"},"correct":"B","explanation":"Python lists are zero-indexed, meaning the first element is at index 0, the second at index 1, and so on.  Therefore, to access the third element, you need to use index 2: my_list[2]. Option A is incorrect because it uses parentheses, which are used for function calls, not list indexing. Option C is incorrect because it tries to access the fourth element. Option D is incorrect because  `.get()` is a method used with dictionaries, not lists."},{"question_number_text":"Q2.","question":"Which of the following statements accurately describes the mutability of Python lists?","code":"","options":{"A":"Python lists are immutable; once created, their elements cannot be changed.","B":"Python lists are immutable; their size cannot be changed, but elements can be modified.","C":"Python lists are mutable; both their size and elements can be changed.","D":"Python lists are mutable; their size can be changed, but elements cannot be modified."},"correct":"C","explanation":"Python lists are mutable data structures. This means you can modify their contents (change existing elements) and change their size (add or remove elements) after they have been created.  Options A, B, and D incorrectly describe the mutability of lists."}],"time_limit":30}
------------------------------------
Testing Intermediate Quiz...
URL: http://localhost:8000/generate-quiz
Payload: {"topic": "Python functions", "question_number": 2, "level": "intermediate"}
Status Code: 200
Response Body:
{"questions":[{"question_number_text":"Q1.","question":"What will be the output of the following Python code?","code":"def outer_function(x):\ny = x * 2\ndef inner_function(z):\nreturn y + z\nreturn inner_function\nclosure = outer_function(5)\nresult = closure(3)\nprint(result)","options":{"A":"8","B":"13","C":"10","D":"15"},"correct":"B","explanation":"This code demonstrates closures. The `inner_function` \"closes over\" the variable `y` from its enclosing scope (`outer_function`).  Even after `outer_function` has finished executing, `inner_function` retains access to the value of `y` (which is 10 because `x` is 5 and `y` is `x*2`). Therefore, `closure(3)` calculates `10 + 3`, resulting in 13."},{"question_number_text":"Q2.","question":"Which of the following statements regarding Python function arguments is FALSE?","code":"def my_function(a, b=2, *args, **kwargs):\nprint(a, b, args, kwargs)\nmy_function(1, 3, 4, 5, c=6, d=7)","options":{"A":"`a` is a positional argument.","B":"`b` is a keyword argument with a default value.","C":"`*args` will be a tuple containing (4, 5).","D":"`**kwargs` will be a dictionary containing only {'c':6}."},"correct":"D","explanation":"`**kwargs` is a dictionary that collects all keyword arguments that are *not* explicitly defined in the function signature.  Therefore, `**kwargs` will be `{'c': 6, 'd': 7}`, not just `{'c':6}`.  Option A, B, and C are all true statements about the function's arguments."}],"time_limit":45}
------------------------------------
Testing Advanced Quiz...
URL: http://localhost:8000/generate-quiz
Payload: {"topic": "Python decorators", "question_number": 2, "level": "advanced"}
Status Code: 200
Response Body:
{"questions":[{"question_number_text":"Q1.","question":"Which of the following statements BEST describes the fundamental advantage of using decorators over directly modifying a function's behavior in Python?","code":"","options":{"A":"Decorators offer superior performance due to optimized bytecode generation.","B":"Decorators provide a cleaner, more readable way to apply cross-cutting concerns without altering the function's core logic.","C":"Decorators enable easier debugging by encapsulating modification logic within separate functions.","D":"Decorators are necessary for implementing advanced features such as metaclasses and abstract base classes."},"correct":"B","explanation":"While options C and D are partially true in specific contexts, the primary advantage of decorators is their ability to enhance functions with additional functionality (logging, timing, authorization, etc.) without altering the original function's source code.  This leads to improved code readability and maintainability.  Performance gains are not inherent to decorators themselves, and while they can contribute to better organization that may aid debugging, it's not their central benefit."},{"question_number_text":"Q2.","question":"Consider a scenario where you need to apply multiple decorators to a single function.  How does Python handle the order of decorator execution, and what implications does this have for decorator design?","code":"","options":{"A":"Python executes decorators in the order they are declared, from bottom to top.  This means the order of definition is inconsequential.","B":"Python executes decorators in the order they are declared, from top to bottom.  Decorator order must be carefully considered to avoid unexpected interactions.","C":"Python executes decorators in a random order, requiring careful testing to ensure correct functionality.","D":"Python executes decorators concurrently, demanding thread-safe decorator implementations."},"correct":"B","explanation":"Python applies decorators in the order they are listed in the function definition, from top to bottom.  This means that the output of one decorator becomes the input of the next. If the decorators have dependencies or interact in specific ways, the order is crucial.  Incorrect ordering can lead to functional errors or unexpected results.  Decorators are not inherently executed concurrently, and the order is deterministic rather than random."}],"time_limit":60}
------------------------------------
--- /get-explanation test ---
Testing Get Explanation (Intermediate)...
URL: http://localhost:8000/get-explanation
Payload: {"topic": "Python functions", "num_questions": 2, "level": "intermediate", "question_index": 0}
Status Code: 200
Response Body:
{"explanation":"Lists in Python are mutable.  The `modify_list` function modifies the original list passed as an argument (`my_list`) by using the `append()` method.  Therefore, both `my_list` and `new_list` will reflect the change, resulting in `[1, 2, 3, 4]` being printed."}
------------------------------------
Killing server PID: 2876
Backend tests finished.
